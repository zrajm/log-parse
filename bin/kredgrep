#!/usr/bin/perl -w

# [2007-12-12] - [2008-02-02] /Zrajm C Akfohg
#
# FIXME: statusbar in percent (of total bytes to read) -- also time
# based, i.e.  updated say, once or twice a second, but not more often
#
# FIXME: can the progress bar stuff be hidden away in a module?
#
# FIXME: Term::ANSIColor should not be called unless used, and even
# then should fall back gracefully (i.e. simply disable coloured
# output) if it does not exist
#
# FIXME: `cat hej2/* |./kredgrep 'Heid' - --color' causes:
#
#    kredgrep: sysread() on closed filehandle STDIN at /usr/local/share/perl/5.8.8/Log/Parse.pm line 239.
#    Cannot read logfile `': Bad file descriptor at ./kredgrep line 573
#
# Prolly since it opens STDIN twice. Fix this!
#

use strict;
use lib do {        # add script's directory to @INC
    use File::Spec; # to prettify path
    use Cwd;        # to follow symlinks in path
    my ($vol, $dir) = File::Spec->splitpath(Cwd::abs_path($0));
        $dir        = File::Spec->catdir(File::Spec->splitdir($dir));
    File::Spec->catpath($vol, $dir, '');
};  
use Term::ANSIColor;
use Time::Local;
#use Time::HiRes 'alarm';             # progress bar needs this
#use Term::ReadKey 'GetTerminalSize'; # progress bar needs this
use Term::ProgressMeter;


###############################################################################
##                                                                           ##
##  Documentation                                                            ##
##                                                                           ##
###############################################################################


=head1 NAME

kredgrep - search through kredsystem log files

=head1 SYNOPSIS

B<kredgrep> [OPTION]... PATTERN [KREDLOGFILE]...

=head1 DESCRIPTION

B<kredgrep> searches the named input KREDLOGFILEs (or standard input if no files
are named, or if the file name `-' is given) for entries containing a match to
the given PATTERN. By default, B<kredgrep> prints the matching lines.

B<Kredgrep> is intentionally quite similar to traditional B<grep>, but is specific
for logs generated by the kred system. Instead of considering lines, it
consideres (sometimes multiline) log entries. It also implements some
improvements over traditional B<grep> which are quite handy (especially when
grepping through I<huge> logfiles) such as the progress bar on standard error.


=head1 OPTIONS

=over 8

=item B<-a>, B<--after>=I<TIME>

Only match entries occuring after I<TIME>. Time must be expressed in format:
`YYYY-MM-DD HH:MM:SS' but you may leave off trailing elements down to only the
year (i.e. use any of `YYYY', `YYYY-MM', `YYYY-MM-DD', `YYYY-MM-DD HH',
`YYYY-MM-DD HH:MM' or `YYYY-MM-DD HH:MM:SS').


=item B<-b>, B<--before>=I<TIME>

Only match entries occuring before I<TIME>. Time must be expressed in format:
`YYYY-MM-DD HH:MM:SS' but you may leave off trailing elements down to only the
year (i.e. use any of `YYYY', `YYYY-MM', `YYYY-MM-DD', `YYYY-MM-DD HH',
`YYYY-MM-DD HH:MM' or `YYYY-MM-DD HH:MM:SS').


=item B<-c>, B<--count>=I<TIME>

Suppress normal output; instead print a count of matching lines for each input
file. With the B<--invert-match> option (see below), count non-matching lines.
(Same as the traditional B<grep> option with the same name.)


=item B<--colour>[=I<WHEN>], B<--color>[=I<WHEN>]

As in traditional B<grep>. Surround the matching string with the marker found in
GREP_COLOR environment variable. WHEN may be `never', `always', or `auto'. In
`auto' mode no colors are used if output is piped to another program (or another
instance of B<kredgrep>).


=item B<-d>, B<--duration>=I<PERIOD>

Searches for entries dated in the time PERIOD before (if used together with
B<--before>) or after (with B<---after>) a specified date, or before the current
time (if neither B<---before> nor B<---after> was given on the same command line).

PERIOD is one or more numbers suffixed with any of the letters `wdhms' (for
I<w>eeks, I<d>ays, I<h>ours, I<m>inutes or I<s>econds). If so suffix is used,
seconds are assumed. E.g. `--duration=1w2d' for `one week and two days'.

Example: `--after=2000-01-01 --duration=1w' searches for entries from the first
week of January 2000, while `--before=2000-01-01 --duration=1w' searches the
last week of December 1999.


=item B<-f>, B<--force>

Will cause output dir to be erased before searching. Normally, if you specify an
B<---output-dir> that already exists, B<kredgrep> will print a warning and exit.
When using B<---force> that directory will instead be erased. Use with caution.

Only meaningful in combination with B<---output-dir>.


=item B<-H>, B<--with-filename>

Print the filename for each match. This option is enabled by default when more
than one file was specified on the command line. Does not affect files written
with B<--output-dir>, which never contain the filename. (Same as the traditional
B<grep> option with the same name.)


=item B<-h>, B<--no-filename>

Suppress the prefixing of filenames on output when multiple files are searched.
(Same as the traditional B<grep> option with the same name.)


=item (B<-h>), B<--help> (B<-h> works if is the only argument on the command
line)

Output a brief help message and exit.


=item B<-i>, B<--ignore-case>

Ignore case distinctions in both the PATTERN and the input files. (Same as the
traditional B<grep> option with the same name.)


=item B<-o>, B<--output-dir>=I<DIR>

Writes each found entry to (a sequentially numbered) file in DIR. Filenames are
in the format `NAME.00000001.EXT' (where NAME and EXT are taken from the source
file, and the number indicating which match is is in the original file). This
option might be useful to split/extract parts of a log for use with other
line-based (as opposed to log entry-based) tools.

NOTA BENE: B<kredgrep> requires that DIR does not already exist, unless you use
the B<--force> option, in which case DIR will be B<erased> before searching
starts. (Use with caution!)

For increased speed you might want to combine B<--output-dir> with B<--quiet>
(scrolling text in the terminal is major source of slowness).

Options B<--with-filename> and B<--no-filename> only affect screen output, and
have no effect on what is written to file.


=item B<-P>, B<--no-progress>

Disable the progress bar (automatically disabled if standard error is
redirected, or if B<---quiet> is used.)


=item B<-p>, B<--progress>

Enable the progress bar on standard error (is enabled per default, except if
standard error is redirected, or if using B<---quiet>).


=item B<-q>, B<--quiet>

Don't produce any output on standard out (except possible progress bar). This is
mostly useful in combination with B<--output-dir>, but since B<kredgrep> will
exit with exit status 1 if nothing where found, and 0 otherwise it might also be
useful is conditional clauses.


=item B<-v>, B<--invert-match>

Invert the sense of matching, to select non-matching lines. (Same as the
traditional B<grep> option with the same name.)


=item B<-w>, B<--word-regex>, B<--word-regexp>

Select only those lines containing matches that form whole words. The test is
that the matching substring must either be at the beginning of the line, or
preceded by a non-word constituent character. Similarly, it must be either at
the end of the line or followed by a non-word constituent character.
Word-constituent characters are letters, digits, and the underscore. (Same as
the traditional B<grep> option with the same name.)

=back


=head1 RETURN VALUE

Exit with exit status 0 on successful (one or more) match, and exit status 1 if
no matches were found. Exit status is set 5 if there was a problem somewhere
(most likely this means that the search was not performed at all).

If interrupted or killed, returns 255.

=head1 EXAMPLES


Output all log entries from this last week. (This actually searches for all log
entries containing the empty string, which will match all of them.):

    kredgrep -d 1w '' etrans.log


Search for all log entries in `estore.log' containing both the string `eid=442'
and `karlsson' (`karlsson' without regard to case):

    kredgrep 'eid=442' estore.log | kredgrep -i karlsson

Search for all log entries containing both the string `eid=442' and `karlsson',
where `karlsson' occurs after `eid=442' (here we use the regex `.*' which
matches anything):

    kredgrep -i 'eid=442.*karlsson' estore.log

To split `alarm.log' into entries, and write them as sequentially numbered files
into a directory called `alarm':

    kredgrep --output-dir=alarm '' alarm.log

Output all entries, in all logfiles in the current directory, which is from the
beginning of the year 2008 and forward.

    kredgrep --after=2008-01-01 '' *


=head1 ENVIRONMENT

=over 8

=item B<GREP_COLOR>

This is an environment variable used by traditional B<grep>, which is also used
by B<kredgrep> if it is set. It specifies the marker for highlighting.

=item B<KREDGREP_COLOR>

If set this overrides any color specified in B<GREP_COLOR>. Use this if you want
specific settings, not shared by traditional B<grep>.

=back


=head1 NOTES

This program, being written in perl, uses the B<perl> flavour of regexes.


=head1 PREREQUISITES

Beyond the standard Perl installation B<kredgrep> requires the modules
C<Term::ANSIColor> and C<Term::ReadKey> to work.

It also requires the C<Log::Parse> module, which it is distributed
with.


=head1 SEE ALSO

grep(1), perlre(1), Log::Parse(3)

http://zrajm.klingonska.org/programs/Log-Parse/


=head1 AUTHOR

Zrajm C Akfohg, E<lt>kredgrep-mail@klingonska.orgE<gt>. Feel free to contact me
with suggestions and/or bugs!


=head1 COPYRIGHT AND LICENSE

Copyright 2007-2008 by Zrajm C Akfohg.

Published under a Creative Commons Attribution-Share Alike 3.0 license.
[http://creativecommons.org/licenses/by-sa/3.0/]

=cut



###############################################################################
##                                                                           ##
##  Informational Functions                                                  ##
##                                                                           ##
###############################################################################


sub TRUE()  {  1 }
sub FALSE() { '' }
sub help() {
    (my $mybin = $0) =~ s{^.*/}{};
    print <<EOF;
Usage: $mybin [OPTION]... PATTERN [KREDLOG]...
Search KREDLOG(s) (or standard input) for entries containing PATTERN.

  -a, --after=TIME       match only log entries after TIME
  -b, --before=TIME      match only log entries before TIME
      --color=[WHEN]     highlight matching strings with colours
                         WHEN may be \`always\', \`never\' or \`auto\'.
  -d, --duration=PERIOD  period to search (before now, or before/after
			 time given with \`--before' or \`--after')
  -f, --force            delete output dir before searching
      --help             display this help and exit
  -i, --ignore-case      ignore case distinctions
  -H, --with-filename    print the filename for each match
  -h, --no-filename      suppress the prefixing filename on output
  -o, --output-dir=DIR   write each matching log event into a
                         separate, numbered file in DIR
  -P, --no-progress      disable search progress display
  -p, --progress         progress bar STDOUT (default on terminal)
  -q, --quiet            don\'t output anything on STDOUT
  -v, --invert-match     select non-matching events
  -w, --word-regexp      force PATTERN to match only whole words

TIME is specified in "YYYY-MM-DD HH:MM:SS" format, but may be shortened from the
end by any number of fields (though, minimally you must specify the year in four
digit format).

PATTERN is a Perl regular expression (see "man perlre"), and may not be omitted.
Use an empty pattern ("") to match anything (useful together with e.g. --before,
--after and --count).

To search for logentries matching several PATTERNs in no particular order, pipe
the output of $mybin to itself. E.g.:

    cat SOME_KREDLOG | $mybin PATTERN1 | $mybin PATTERN2

Exit status: 0 = matches, 1 = no matches, 5 = errors.
EOF
    exit;
}



###############################################################################
##                                                                           ##
##  Functions                                                                ##
##                                                                           ##
###############################################################################


# write list of stuff to file
sub save_list($@) {
    my ($file, @list) = @_;
    my $fh;
    local $_;
    open($fh, '>', "$file") and do {
        print $fh map { "$_\n" } @list;
    }
}

# convert start/end time to epoch
sub parse_time {
    my ($time) = @_;
    my @t = $time =~ m{(\d+) (?:-(\d+) (?:-(\d+)
        (?:[\s_.]+ (\d+) (?:[.:](\d+) (?:[.:](\d+))?)?)?)?)?}x
	or return FALSE;
    foreach (@t[3,4,5]) { defined($_) or $_ = 0 }
    foreach (@t[1,2])   { defined($_) or $_ = 1 }
    return timelocal reverse($t[0], $t[1]-1, @t[2,3,4,5]);
}



###############################################################################
##                                                                           ##
##  Initialization                                                           ##
##                                                                           ##
###############################################################################


%SIG = (
    __DIE__  => sub {
	(my $mybin = $0) =~ s{^.*/}{};
	warn "$mybin: $_[0]";
	exit 5;
    },
    __WARN__ => sub {
	(my $mybin = $0) =~ s{^.*/}{};
	warn "$mybin: $_[0]";
    },
);


# parse command line options
die "Not enough arguments\n" .
    "Try `$0 --help' for more information.\n" unless @ARGV;
my ($output_dir, $ignore_case, $force, $quiet, $word_regexp, $invert_match,
    $colour, $count) =
    (FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE);
my ($with_filename, $progress, $duration, $start_time, $end_time) =
    (undef, undef, undef, undef, undef);
my @color;
{
    my ($badargs, @arg) = (0);
    while (@ARGV) {
	local $_ = shift;
	m/^(?:-a|--after)(=(.*))?$/x and do {
	    my ($opt, $arg) = ($1, defined($2) ? $3 : shift);
	    $start_time = parse_time($arg) or do {
		warn "Invalid time expression `$arg' for option `$opt'\n";
		$badargs ++;
	    };
	    next;
	};
	m/^(-b|--before)(=(.*))?$/x and do {
	    my ($opt, $arg) = ($1, defined($2) ? $3 : shift);
	    $end_time = parse_time($arg) or do {
		warn "Invalid time expression `$arg' for option `$opt'\n";
		$badargs ++;
	    };
	    next;
	};
	m/^(?:-c|--count)$/x and do {
	    $count = TRUE;
	    next;
	};
	m/^(?:-d|--duration)(=(.*))?$/x and do {
	    $duration = defined($1) ? $2 : shift;
	    next;
	};
	m/^(--colou?r)(=(.*))?$/x       and do {
	    my $opt = $1;
	    foreach ($colour = defined($2) ? $3 : 'auto') {
		m/^(?:never|none|no)$/ and do { $colour = FALSE;     next };
		m/^(?:force|yes)$/     and do { $colour = TRUE;      next };
		m/^(?:auto|if-tty)$/   and do { $colour = -t STDOUT; next };
		warn "Unknown argument `$_' for option `$opt'\n";
		$badargs ++;
	    }
	    next;
	};
	m/^(-f|--force)$/         and do { $force           = TRUE;  next };
	m/^(-h|--no-filename)$/   and do { (@arg + @ARGV   == 0) and help;
	                                   $with_filename   = FALSE; next };
	m/^(-H|--with-filename)$/ and do { $with_filename   = TRUE;  next };
	m/^--help$/               and do { help };
	m/^(-i|--ignore-case)$/   and do { $ignore_case     = TRUE;  next };
	m/^(-o|--output-dir)(=(.*))?$/ and do {
	    $output_dir = defined($2) ? $3 : shift;
	    if (not defined $output_dir or $output_dir eq '') {
		warn "No output dir specified when using the `$1' option\n";
		$badargs ++;
		next;
	    }
	    next;
	};
	m/^(-p|--progress)$/      and do { $progress      = TRUE;  next };
	m/^(-P|--no-progress)$/   and do { $progress      = FALSE; next };
	m/^(-q|--quiet)$/         and do { $quiet         = TRUE;  next };
	m/^(-v|--invert-match)$/  and do { $invert_match  = TRUE;  next };
	m/^(-w|--word-regexp?)$/  and do { $word_regexp   = TRUE;  next };
	m/^--$/ and last;
	m/^-./  and do { warn "Unknown option `$_'\n"; $badargs ++; next; };
	push @arg, $_;
    }
    unshift @ARGV, @arg;
    if ($colour) {
	local $SIG{__DIE__} = sub {
	    $_[0] =~ m/^No name for escape sequence (55)/ and
	    die "Unknown ANSI escape sequence `$1' " .
	        "in \$KREDGREP_COLOR or \$GREP_COLOR.\n";
	};
	@color = eval {
	    Term::ANSIColor::uncolor(
		$ENV{KREDGREP_COLOR} || $ENV{GREP_COLOR} || '01;31'
	    );
	};
	if ($@) {
	    @color = Term::ANSIColor::uncolor('01;31');
	    warn $@;
	}
    }
    # set start/end time if duration is used
    if (defined $duration) {
	my ($tmp, %t) = qw(0 w 604800 d 86400 h 3600 m 60 s 1);
	while ($duration =~ / \s* (\d+) \s* ([wdhms])? /gix) {
	    $tmp += defined($2) ? $1*$t{$2} : $1;
	}
	$duration = $tmp;
	if ($start_time && $end_time) {
	    warn "Cannot use all three of `--duration', `--before' and `--after'\n";
	    $badargs++;
	} elsif ($start_time) { $end_time   = $start_time + $duration }
	elsif   ($end_time)   { $start_time = $end_time   - $duration }
	else                  { $start_time = time()      - $duration }
    }
    exit 5 if $badargs;
}


# check command line arguments
my $regex = shift;

# check files given on command line
unshift @ARGV, '-' if not -t STDIN;
if (@ARGV == 0) {
    die "No input files specified, and nothing to read on standard input\n"
}

# default `--no-filename'/`--with-filename' behaviour
# (on if more than one file given on command line)
if (not defined($with_filename)) {
    $with_filename = (@ARGV > 1) ? TRUE : FALSE;
}

# default `--progress' behaviour
# (on unless STDERR is redirected, or `--quiet' is used)
if (not defined($progress)) {
    $progress = (-t STDERR) ? ($quiet ? FALSE : TRUE) : FALSE;
}

# disable normal output on `--count'
$quiet = TRUE if $count;

# output dir stuff
if ($output_dir ne '') {
    rmdir $output_dir; # remove dir if empty
    system(qw/rm -rf/, $output_dir)
	if $force and -d $output_dir;
    mkdir $output_dir or
	die "Can't create output directory: $!\n";
}

# init Log::Parse for kredlogs
use Log::Parse;
our %month = (
    Jan => 0,  Feb => 1,  Mar => 2,  Apr => 3,  May =>  4,  Jun =>  5,
    Jul => 6,  Aug => 7,  Sep => 8,  Oct => 9,  Nov => 10,  Dec => 11,
);
my $month_re = join('|', keys %month);
my $log = Log::Parse->new(
    # logevent headers matched:
    #   == 7-Nov-2007::20:31:07 == [...]
    #   kred@lax      2007-02-13 23:15:05 [...]
    #   kred@lax      2005-05-24 02:30:0  [...]
    entry_regex => qr/^(?:
        ==\s+ (\d+)-($month_re)-(\d+) :: (\d+):(\d+):(\d+) \s+ |
        (?:\w+\s+)? \w+@\w+ \s+ (\d+)-(\d+)-(\d+) \s+ (\d+):(\d+):(\d+) \s+
    )/mox,
    entry_callback => sub {
	# return seconds since epoch (zero on error)
	return do {
	    if (defined $_[0]) {
		timelocal(@_[5, 4, 3, 0], $month{$_[1]}, $_[2]);
	    } elsif (defined $_[6]) {
		timelocal(@_[11, 10, 9, 8], $_[7]-1, $_[6]);
	    } else {
		0;
	    }
	};
    },
);

# progress bar stuff
my ($on_screen, $term_width) = (FALSE, FALSE);  #
my $total_size = 0;                             #
my $bytes_read = 0;
if ($progress) {                                #
    foreach my $infile (@ARGV) {                # calc total size of all files
	$total_size += (stat $infile)[7];       #   to search
    }                                           #
    $total_size = 1 if $total_size == 0;        # not zero (used in division)
    Term::ProgressMeter::set(                   # invoke Term::ProgressMeter
        update_interval => .1,                  #   every tenth of a seconds
        max_value       => \$total_size,        #   reference to maximum count
        current_value   => sub {                #
	    $bytes_read + $log->position();     #
	},                                      #
   );                                           #
} else {                                        #
    $SIG{INT} = $SIG{TERM} = sub {              # on kill or ^C
	exit 255;                               #
    };                                          #
}                                               #

# create regex to search for
$regex = "\b$regex\b"    if $word_regexp;
$regex = qr/(?i:$regex)/ if $ignore_case;
$regex = '' unless defined($regex);



###############################################################################
##                                                                           ##
##  Main                                                                     ##
##                                                                           ##
###############################################################################


# $matches is reset for each file. It starts as '', but if ever set, it is then
# reset to '0', so that we might at the end distinguish '' (no match occured)
# from '0' (match occured, but not in last file) when deciding the program exit
# code. /zrajm [2008-02-03]

my $began_at = time();
my ($matches, $files, $infile) = ('', scalar(@ARGV), '');
my @prev_time;
FILE: foreach $infile (@ARGV) {                 # for each input file
    # open kredlog file
    my $prefix = ($with_filename && $infile) ? "$infile:" : "";
    defined($log->open($infile)) or do {        #   open file
	warn "Cannot open file `$infile': $!\n";#
	next FILE;                              #
    };                                          #
    # process file
    while (($_, my $epoch) = $log->read()) {    #   for each entry
	next if defined $start_time and $epoch < $start_time;
	next if defined $end_time   and $epoch > $end_time;
	next unless /$regex/mo xor $invert_match;
	$matches ++;                            #
	if ($output_dir) {                      #     `--output-dir'
	    my $file = (File::Spec->splitdir($infile))[-1];
	    my $ext  = ($file =~ s/\.([^.]+?)$//) ? $1 : '.log';
	    $file    = join '.', grep { $_ ne '' }
		$file, sprintf('%08s', $matches), $ext;
	    my $outfile = File::Spec->catdir(   #
		$output_dir, $file);            #
	    save_list($outfile, $_);            #
	}                                       #
	next if $quiet;                         #     `--quiet'
	if (@color and not $invert_match) {     #     `--color'
	    s/($regex)/colored($1, @color)/e;   #
	}                                       #
	Term::ProgressMeter::hide;              #
	print $prefix . $_;                     #
    }                                           #
    # after processing file
    if ($count) {                               #   `--count'
	Term::ProgressMeter::hide;              #
	print $prefix . ($matches || 0) . "\n"; #
    }                                           #
    $files --;                                  #
    $matches = 0 if $matches;                   #   reset maches for each file
    $bytes_read += $log->position();            #
}                                               #
exit 1 if $matches eq '';                       #

#[[eof]]
