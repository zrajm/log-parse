#!/usr/bin/perl -w

# [2007-12-12] /Zrajm C Akfohg

# FIXME: Use module for keeping multiple (output) files open.
# FIXME: Sorting of output?

use strict;
use lib do {        # add script's directory to @INC
    use File::Spec; # to prettify path
    use Cwd;        # to follow symlinks in path
    my ($vol, $dir) = File::Spec->splitpath(Cwd::abs_path($0));
        $dir        = File::Spec->catdir(File::Spec->splitdir($dir));
    File::Spec->catpath($vol, $dir, '');
};  
use Term::ANSIColor;
use Log::Parse;



############
##  Subs  ##
############


sub TRUE()  { 1  }
sub FALSE() { '' }
sub help()  {
    (my $mybin = $0) =~ s{^.*/}{};
    print <<EOF;
Usage: $mybin [OPTION]... KREDLOGDIR... DESTDIR
Read KREDLOG(s), write new kredlogs with date-based filenames in DESTDIR.

  -f, --force               overwrite non-kredlog directory (if DESTDIR)
  -h, --help                display this help and exit
  -p, --progress            show current file on STDERR (default)
  -P, --no-progress         disable progress

KREDLOGDIR is a directory (searched recursivelly) containing one or more
logfiles from the kredsystem.

DESTDIR is a directory (either non-existing, or generated by a previous
invocation of $mybin) containing subirs and files looking like this:

    YYYYMMDD/HHMMSS/MD5/LOGNAM


SPEEDYNESS:

If a file has grown since it was last processed, $mybin will continue to parse
the file where the last invocation left off. However, if the file has been
clobbered/rewritten since then (i.e. the first log entry differs from the old
version), the file will instead be read from the beginning.

EOF
    exit;
}


# display "twirling baton" on STDERR
sub progress(;$) {
    my ($string) = @_;
    print STDERR " $string\e[K\r";
    return $string eq '' ? FALSE : TRUE;
}



############
##  Init  ##
############

# parse command line options
my ($progress, $force) = (undef, FALSE);
{
    my ($badargs, @arg) = (0);
    while (@ARGV) {
	local $_ = shift;
	m/^(-h|--help)$/        and do { help };
	m/^(-f|--force)$/       and do { $force     = TRUE;  next };
	m/^(-p|--progress)$/    and do { $progress  = TRUE;  next };
	m/^(-P|--no-progress)$/ and do { $progress  = FALSE; next };
	m/^--$/ and last;
	m/^-./  and do { warn "$0: unknown option `$_'\n"; $badargs ++; next; };
	push @arg, $_;
    }
    unshift @ARGV, @arg;
    exit 5 if $badargs;
}
if (not @ARGV) {
    warn "$0: Not enough arguments\n";
    warn "Try `$0 --help' for more information.\n";
    exit 5;
}

my $output_dir =  pop @ARGV;
$output_dir    =~ s{/+$}{};
my $resume_dir =  "$output_dir/.kredlogconvert";

# FIXME do check of destdir here!
#if (-e $output_dir and not -d "$output_dir/$resume_dir" and not $force) {
#    warn "$0: Destination directory exists, but does not appear to be a kredlog directory\n";
#    warn "(Is not a directory, or does not contain a `$resume_dir' subdirectory.)\n";
#    exit 5;
#}

system "mkdir -p $output_dir";

# default "progress" behaviour
$progress = (-t STDERR) ? TRUE : FALSE
    unless defined($progress);




############
##  Main  ##
############


# Regex matching the following headers:
#     == 7-Nov-2007::20:31:07 == [...]
#     kred@lax      2007-02-13 23:15:05 [...]
our %month = (
    Jan => 0,  Feb => 1,  Mar => 2,  Apr => 3,  May =>  4,  Jun =>  5,
    Jul => 6,  Aug => 7,  Sep => 8,  Oct => 9,  Nov => 10,  Dec => 11,
    );
my $month_re = join('|', keys %month);
my $log = Log::Parse->new(
    resume_dir     => $resume_dir,
    entry_regex    => qr/^([0-9a-z*=](?:
        =[ ](\d\d?)-($month_re)-(\d\d\d\d)::(\d\d):(\d\d):(\d\d)[ ]== |
        (?:\w+[ ])?? (?:[*]+|\w+@\w+) [ ]+ (\d\d\d\d)-(\d\d)-(\d\d)[ ](\d\d):(\d\d):(\d\d)
    )[ ])/mox,
    entry_callback => sub {
	my $head = shift;
	my @time = do {
	    if (@_[0..5]) {
		(@_[5, 4, 3, 0], $month{$_[1]}, $_[2]);
	    } elsif (@_[6..11]) {
		(@_[11, 10, 9, 8, 7, 6]);
	    }
	};
	$time[5] < 1000 and $time[5] += 1900;
	if (@time == 6) {
	    return sprintf("%4u-%02u-%02u", @time[5,4,3]), sprintf("%02u:%02u:%02u", @time[2,1,0]), length($head);
	}
	return 0;
    },
);


# FIXME: Atomic updates. Ctrl-C, and then resume should cause no more to be
# written than a single, uninterrupted pass: Copy destfile to destfile.tmp,
# write to the tempfile. If interrupted/killed, delete the tempfile -- if not,
# move tempfile to original file. (Bad, because takes much extra dispace? And
# copying back and forth is slow?)
#
# Or, maybe, don't muck about with tempfiles, just save current offset on
# receiving SIGINT. (Bad, because SIGKILL will leave the output files in a
# bess).


my @file;
while (@ARGV) {
    my $file = shift @ARGV;
    -d  $file and do { push @ARGV, sort glob("$file/*"); next };
    -f  $file and do { push @file, $file;                next };
    # FIXME: do some prechecks. fail un unreadable files, follow links + more?
    print "will ignore file `$file': It is neither file nor dir\n";
}


sub save_entry {
    my ($file, $entry) =  @_;
    (my $dir = $file)  =~ s{/+[^/]*$}{};
    my $i = 1;
    if (not -d $dir) {
	!system "mkdir -p $dir"  or die "Cannot create dir `$dir' for output file: $!";
    } else {
	$i++ while -f "$file.$i";
    }
    open my $fh, '>', "$file.$i" or die "Cannot open file `$file' for writing: $!";
    print $fh $entry             or die "Cannot write to file `$file': $!";
    close $fh                    or die "Cannot close file `$file' after writing: $!";
}


$|=1;
use Digest::MD5;
foreach my $file (@file) {
#    progress("$file") if $progress;
    $log->open($file);                          #
    my $base = $file;
    $base =~ s/^.*\///;
    $base =~ s/\.\d+$//;
    while (my ($entry, $date, $time, $headlen) = $log->read()) { #
	progress("$file->$output_dir/$date/$time/".Digest::MD5::md5_hex(substr($entry, $headlen))."/$base") if $progress;
	save_entry("$output_dir/$date/$time/".Digest::MD5::md5_hex(substr($entry, $headlen))."/$base", $entry);
    }
    $log->close();
}



__END__


my $fh = undef;                                 #
foreach my $file (@ARGV) {                      # for each argument/file
    my ($base, $lastfile) = ($file, '');        #
    $base =~ s{^.*/}{};                         #   strip path
    $base =~ s{\.\d*$}{};                       #   strip number extension
    $log->open($file);                          #
    while (my ($entry, $date) = $log->read()) { #
	my $outfile = "$output_dir/$date/$base.log";
	my $outdir  = "$output_dir/$date";      #
	if ($outfile ne $lastfile) {
	    progress("$file->$outfile") if $progress;
	    defined($fh) and close $fh;
	    -d "$outdir" or mkdir $outdir;
	    open $fh, '>>', $outfile;
	}
	print $fh $entry;
	$lastfile = $outfile;
    }
    $log->close();
}
defined($fh) and close $fh;

#[[eof]]
